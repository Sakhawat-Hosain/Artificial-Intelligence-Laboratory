# -*- coding: utf-8 -*-
"""011221240.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SAg1B-ZbrrvpRyFrRp7x0bKfroHHEJcl
"""

#A* search

#Part 1
adjacency_list = {                #Keep a dictionary of the adjacent list as adjacency_list:
    'S': [('A', 1), ('B', 4)],    #Nodename as key, value as list of tuples
    'A': [('B', 2), ('C', 5), ('G', 12)],
    'B': [('C', 2)],
    'C': [('D', 2), ('G', 3)],
    'D': [('G', 2), ('A', 2)],
    'G': [('C', 4)]
}
H = {         #Keep another dictionary as H: Nodename as key, heuristic value as value
    'S': 7,
    'A': 6,
    'B': 2,
    'C': 1,
    'D': 1,
    'G': 0
}

#Part 2
class Node:
    def __init__(self, nodename, parent, g, h):
        self.name = nodename
        self.parent = parent
        self.g = g   #g(n)
        self.h = h   #h(n)
        self.f = g + h  #f(x)

#Part 3
priority_queue = []   #emptyt list

def push_sort(node):  # push node and sort the priority queue
    priority_queue.append(node)
    priority_queue.sort(key = lambda x: x.f)

def is_empty():
    return len(priority_queue) == 0

NOb = Node('S', None, 0, H['S'])   #source Node
push_sort(NOb)  #insert source node

while not is_empty():
    Nob = priority_queue.pop(0)

    if Nob.name == 'G':
        break

    for neighbor in adjacency_list[Nob.name]:
        new_node = Node(nodename = neighbor[0], parent = Nob, g = Nob.g+neighbor[1], h = H[neighbor[0]])
        push_sort(new_node)
    Nob = None

#Part 4
path = []
cost = Nob.g

while Nob.parent is not None:
    path.insert(0, Nob.name)
    Nob = Nob.parent

path.insert(0, Nob.name)

print("Path:", path)
print("Path Cost = ", cost)